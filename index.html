<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chúc Mừng Sinh Nhật ❤️</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.js library for 3D graphics -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
        }
        canvas {
            display: block;
        }
        #matrixCanvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }
        #fireworks3dContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none; /* Hide initially */
        }
        .intro-text, .countdown, .dynamic-text, .card-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            font-weight: bold;
            color: #00bfff; /* Updated to a brighter blue */
            text-shadow: 0 0 15px #00bfff; /* Updated text shadow */
            z-index: 20;
            opacity: 0;
            transition: opacity 1s ease-in-out;
            text-align: center;
        }
        .countdown {
            font-size: 8rem;
            color: #fff;
            text-shadow: 0 0 20px #00bfff;
            z-index: 10;
        }
        .dynamic-text {
            font-size: 5rem;
            color: #00bfff; /* Updated to a brighter blue */
            text-shadow: 0 0 10px #00bfff; /* Updated text shadow */
            z-index: 15;
            white-space: nowrap;
        }
        .card-message {
            /* Cập nhật vị trí để nó xuất hiện phía dưới trái tim */
            top: 75%;
            font-size: 2.5rem; /* Adjusted font size to be smaller */
            color: #fff;
            text-shadow: 0 0 10px #fff;
            white-space: nowrap;
            opacity: 0;
            transition: opacity 1s ease-in-out;
            z-index: 25; /* Higher z-index to be on top */
        }
        
        /* Container for heart particles */
        #heartContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 16;
        }

        /* Heart effect */
        .heart-particle {
            position: absolute;
            width: 20px;
            height: 20px;
            background-color: #00bfff; /* Updated heart color to blue */
            transform: rotate(-45deg);
            opacity: 0;
            animation: heart-fall linear infinite;
        }

        .heart-particle::before,
        .heart-particle::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            background-color: #00bfff; /* Updated heart color to blue */
            border-radius: 50%;
        }

        .heart-particle::before {
            top: -10px;
            left: 0;
        }

        .heart-particle::after {
            left: 10px;
            top: 0;
        }

        @keyframes heart-fall {
            0% {
                transform: translateY(0) rotate(-45deg) scale(0);
                opacity: 0;
            }
            10% {
                transform: translateY(0) rotate(-45deg) scale(1);
                opacity: 1;
            }
            100% {
                transform: translateY(100vh) rotate(-45deg) scale(0);
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <!-- Canvas for the 2D Matrix effect -->
    <canvas id="matrixCanvas"></canvas>
    
    <!-- Container for heart particles -->
    <div id="heartContainer"></div>

    <!-- Container for 3D Three.js scene -->
    <div id="fireworks3dContainer"></div>

    <!-- Introductory text overlay -->
    <div id="introText" class="intro-text"></div>

    <!-- Countdown effect -->
    <div id="countdown" class="countdown">3</div>

    <!-- Dynamic text overlay for the initial sequence -->
    <div id="dynamicText" class="dynamic-text"></div>

    <!-- New element for the card message -->
    <div id="cardMessage" class="card-message"></div>

    <!-- Audio element for background music. -->
    <!-- Loop attribute ensures the music plays continuously. -->
    <audio id="birthdayMusic" loop>
        <source src="https://storage.googleapis.com/gemini-prod-us-west1-1p-20240506-121513/6928935147941.mp3" type="audio/mpeg">
        Trình duyệt của bạn không hỗ trợ phần tử audio.
    </audio>
    
    <script>
        const matrixCanvas = document.getElementById('matrixCanvas');
        const matrixCtx = matrixCanvas.getContext('2d');
        const introTextElement = document.getElementById('introText');
        const countdownElement = document.getElementById('countdown');
        const dynamicTextElement = document.getElementById('dynamicText');
        const cardMessageElement = document.getElementById('cardMessage');
        const heartContainer = document.getElementById('heartContainer');
        const fireworks3dContainer = document.getElementById('fireworks3dContainer');
        const birthdayMusic = document.getElementById('birthdayMusic'); // Get the audio element

        // Get screen dimensions
        const width = window.innerWidth;
        const height = window.innerHeight;
        matrixCanvas.width = width;
        matrixCanvas.height = height;

        // Matrix effect variables
        const oceanCharacters = "happy birthday ";
        const characters = oceanCharacters.split('');
        const fontSize = 16;
        let columns = Math.floor(width / fontSize);
        const drops = [];
        for (let i = 0; i < columns; i++) {
            drops[i] = 1;
        }
        let matrixInterval;
        let isMatrixRunning = false;
        let heartInterval;

        // Three.js variables
        let scene, camera, renderer, particles, particleGeometry;
        const particleCount = 30000; // Increased particle count for better density
        let targetPositions = [];
        let isHeartForming = false;
        let animationFrameId;
        let heartBeatTime = 0; // Thêm biến để tạo hiệu ứng đập

        // Matrix animation loop
        function drawMatrix() {
            matrixCtx.fillStyle = 'rgba(0, 0, 0, 0.05)';
            matrixCtx.fillRect(0, 0, width, height);

            for (let i = 0; i < drops.length; i++) {
                matrixCtx.fillStyle = '#00bfff';
                matrixCtx.font = fontSize + 'px sans-serif';
                matrixCtx.shadowColor = '#00bfff';
                matrixCtx.shadowBlur = 8;
                matrixCtx.shadowOffsetX = 0;
                matrixCtx.shadowOffsetY = 0;

                const text = characters[Math.floor(Math.random() * characters.length)];
                matrixCtx.fillText(text, i * fontSize, drops[i] * fontSize);

                if (drops[i] * fontSize > height && Math.random() > 0.975) {
                    drops[i] = 0;
                }
                drops[i]++;
            }
        }

        // Handle window resizing
        window.addEventListener('resize', () => {
            matrixCanvas.width = window.innerWidth;
            matrixCanvas.height = window.innerHeight;
            if (camera) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
            }
            if (renderer) {
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        });

        // Array of introductory messages
        const introMessages = [
            "Có mở đúng ngày mà em dặn hong đóa",
            "Nếu đúng thì sẽ waoo",
            "còn không thì...",
            "cũm waoo hoi"
        ];
        let introIndex = 0;

        // Display intro messages
        function showIntroMessages() {
            if (introIndex < introMessages.length) {
                introTextElement.textContent = introMessages[introIndex];
                introTextElement.style.opacity = 1;
                introIndex++;
                setTimeout(() => {
                    introTextElement.style.opacity = 0;
                    setTimeout(showIntroMessages, 1000);
                }, 2000);
            } else {
                // After intro messages, start the countdown
                setTimeout(startCountdown, 500);
            }
        }

        // Countdown function
        let countdown = 3;
        function startCountdown() {
            countdownElement.style.opacity = 1;
            const countdownInterval = setInterval(() => {
                countdown--;
                if (countdown > 0) {
                    countdownElement.textContent = countdown;
                } else {
                    clearInterval(countdownInterval);
                    countdownElement.style.opacity = 0;
                    setTimeout(() => {
                        countdownElement.style.display = 'none';
                        showDynamicTextSequence();
                    }, 1000);
                }
            }, 1000);
        }

        // Default hardcoded dynamic messages
        const defaultDynamicMessages = [
            "HAPPY",
            "BIRTHDAY",
            "TO",
            "ANH THY",
            "28.08.2004"
        ];
        let dynamicIndex = 0;

        // Display dynamic messages
        function showDynamicTextSequence() {
            if (dynamicIndex < defaultDynamicMessages.length) {
                dynamicTextElement.textContent = defaultDynamicMessages[dynamicIndex];
                dynamicTextElement.style.opacity = 1;
                
                if (dynamicIndex === 0 && !isMatrixRunning) {
                    matrixInterval = setInterval(drawMatrix, 50);
                    isMatrixRunning = true;
                }

                if (defaultDynamicMessages[dynamicIndex].includes("ANH THY")) { 
                    if (!heartInterval) {
                        heartInterval = setInterval(createHeartParticle, 100);
                    }
                }
                
                let displayDuration = 2500;
                if (defaultDynamicMessages[dynamicIndex].length > 20) {
                    displayDuration = 4000; // Longer duration for longer messages
                }

                setTimeout(() => {
                    dynamicTextElement.style.opacity = 0;
                    setTimeout(showDynamicTextSequence, 1000);
                }, displayDuration);
                dynamicIndex++;
            } else {
                // All messages have been shown, start 3D fireworks
                clearInterval(matrixInterval); // Stop the matrix effect
                if (heartInterval) clearInterval(heartInterval);
                matrixCanvas.style.display = 'none';
                start3DEffect();
            }
        }
        
        // Function to create a single heart particle (2D)
        function createHeartParticle() {
            const heart = document.createElement('div');
            heart.classList.add('heart-particle');
            heart.style.left = `${Math.random() * 100}vw`;
            heart.style.animationDuration = `${Math.random() * 2 + 3}s`;
            heartContainer.appendChild(heart);
            setTimeout(() => {
                heart.remove();
            }, 5000);
        }

        // Three.js initialization and animation
        function start3DEffect() {
            fireworks3dContainer.style.display = 'block';

            // Start playing the music
            birthdayMusic.play().catch(error => {
                // Catches and handles potential autoplay errors in some browsers
                console.log("Autoplay was prevented. User interaction required to play music.");
            });

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            camera.position.z = 100; 
            camera.position.y = -5; // Adjusted camera position to vertically center the heart

            renderer = new THREE.WebGLRenderer({ alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(width, height);
            fireworks3dContainer.appendChild(renderer.domElement);
            
            // Create particles
            particleGeometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const velocities = [];
            
            // Color for particles (a range of blues)
            const color = new THREE.Color();

            for (let i = 0; i < particleCount; i++) {
                positions.push(0, 0, 0);
                const speed = Math.random() * 1.5 + 0.5;
                const angle1 = Math.random() * 2 * Math.PI;
                const angle2 = Math.random() * 2 * Math.PI;
                velocities.push(
                    Math.cos(angle1) * speed,
                    Math.sin(angle1) * speed,
                    Math.cos(angle2) * Math.sin(angle1) * speed
                );

                // Thêm một dải màu xanh biển cả rực rỡ
                color.setHSL(0.55 + Math.random() * 0.15, 1, 0.5 + Math.random() * 0.5);
                colors.push(color.r, color.g, color.b);
            }

            particleGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            particleGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            
            const particleMaterial = new THREE.PointsMaterial({
                size: 1.2, // Updated: Reduced particle size for a finer effect
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                transparent: true,
                opacity: 0.8
            });

            particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);

            // Pre-calculate target positions for the heart shape
            targetPositions = createHeartShapePoints(particleCount, 50); // smaller scale

            // Store the velocities array in userData so animateExplosion can access it
            particleGeometry.userData.velocities = velocities;

            // Start the explosion animation
            animateExplosion();

            // After 3 seconds, start forming the heart immediately
            setTimeout(() => {
                isHeartForming = true;
                dynamicTextElement.style.opacity = 0;
            }, 3000);

            // After the heart has formed, show the card message
            setTimeout(() => {
                showCardMessage();
            }, 6000); // Wait 6 seconds after starting 3D effect to show message

        }

        /**
         * Generates points to fill the volume of a heart shape.
         * @param {number} count The number of particles to generate.
         * @param {number} scale The scale of the heart shape.
         * @returns {Array<{x: number, y: number, z: number}>} An array of point coordinates.
         */
        function createHeartShapePoints(count, scale) {
            const points = [];
            const zThickness = 40; 
            for (let i = 0; i < count; i++) {
                // Generate a random angle on the 2D heart curve
                const t = Math.random() * 2 * Math.PI;
                
                // Generate a random factor to scale the point inward, filling the volume.
                // Using a power function (Math.pow) biases the numbers towards 1,
                // making the outer edge denser.
                const s = Math.pow(Math.random(), 0.3); 
                
                // Calculate heart shape coordinates
                const x = 16 * Math.pow(Math.sin(t), 3);
                const y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
                
                // Apply the scaling factor to fill the 2D area
                const newX = x * s;
                const newY = y * s;
                
                // Add a random Z-coordinate for 3D thickness
                const newZ = (Math.random() - 0.5) * zThickness;
                
                points.push({
                    x: newX * scale * 0.05,
                    y: newY * scale * 0.05,
                    z: newZ * scale * 0.05
                });
            }
            return points;
        }

        // Animation loop for the explosion phase
        function animateExplosion() {
            animationFrameId = requestAnimationFrame(animateExplosion);

            const positions = particleGeometry.attributes.position.array;
            const velocities = particleGeometry.userData.velocities;
            
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                if (!isHeartForming) {
                    // Explosion phase: apply velocity and gravity
                    positions[i3] += velocities[i3] * 0.5;
                    positions[i3 + 1] += velocities[i3 + 1] * 0.5;
                    positions[i3 + 2] += velocities[i3 + 2] * 0.5;
                    velocities[i3 + 1] -= 0.005; // Gravity
                } else {
                    // Heart-forming phase: move towards target position
                    const targetX = targetPositions[i].x;
                    const targetY = targetPositions[i].y;
                    const targetZ = targetPositions[i].z;
                    
                    const dx = targetX - positions[i3];
                    const dy = targetY - positions[i3 + 1];
                    const dz = targetZ - positions[i3 + 2];
                    
                    positions[i3] += dx * 0.05;
                    positions[i3 + 1] += dy * 0.05;
                    positions[i3 + 2] += dz * 0.05;
                }
            }
            particleGeometry.attributes.position.needsUpdate = true;
            
            // Thêm hiệu ứng đập vào đây
            if (isHeartForming) {
                heartBeatTime += 0.05;
                // Sử dụng sin() để tạo hiệu ứng dao động nhịp nhàng
                const scale = 1 + 0.05 * Math.sin(heartBeatTime); 
                particles.scale.set(scale, scale, scale);
            }

            renderer.render(scene, camera);
        }

        // New function to show the card message
        function showCardMessage() {
            // Updated text as requested
            const message = "Chị mở tấm thiệp ra đi nha";
            cardMessageElement.textContent = message;
            cardMessageElement.style.opacity = 1;

            // Add a pulsating effect to the text-shadow
            setInterval(() => {
                cardMessageElement.style.textShadow = `0 0 15px #fff, 0 0 25px #00bfff, 0 0 35px #00bfff`;
                setTimeout(() => {
                    cardMessageElement.style.textShadow = `0 0 10px #fff`;
                }, 500);
            }, 1000);
        }

        // Start the sequence when the page loads
        window.onload = () => {
            showIntroMessages();
        };
    </script>
</body>
</html>

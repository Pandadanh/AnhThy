<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ch√∫c M·ª´ng Sinh Nh·∫≠t ‚ù§Ô∏è</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.js library for 3D graphics -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
        }
        
        /* Orientation warning for mobile devices */
        #orientationWarning {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 999;
            color: #00bfff;
            text-align: center;
            font-family: 'Arial', sans-serif;
        }
        
        #orientationWarning .rotate-icon {
            font-size: 4rem;
            margin-bottom: 1rem;
            animation: rotate-pulse 2s infinite;
        }
        
        #orientationWarning .warning-text {
            font-size: 1.5rem;
            margin-bottom: 0.5rem;
            text-shadow: 0 0 10px #00bfff;
        }
        
        #orientationWarning .sub-text {
            font-size: 1rem;
            opacity: 0.8;
        }
        
        @keyframes rotate-pulse {
            0% { transform: rotate(0deg) scale(1); }
            25% { transform: rotate(90deg) scale(1.1); }
            50% { transform: rotate(90deg) scale(1); }
            75% { transform: rotate(90deg) scale(1.1); }
            100% { transform: rotate(90deg) scale(1); }
        }
        
        /* Hide content on portrait mobile */
        @media screen and (max-width: 768px) and (orientation: portrait) {
            #orientationWarning {
                display: flex !important;
            }
            #matrixCanvas,
            #heartContainer,
            #fireworks3dContainer,
            .intro-text,
            .countdown,
            .dynamic-text,
            .card-message,
            .start-button {
                display: none !important;
            }
        }
        
        /* Optimize for landscape mobile */
        @media screen and (max-width: 768px) and (orientation: landscape) {
            .intro-text, .countdown, .dynamic-text {
                font-size: 2rem;
            }
            .countdown {
                font-size: 4rem;
            }
            .dynamic-text {
                font-size: 3rem;
            }
            .card-message {
                font-size: 1.8rem;
                top: 80%;
            }
            .start-button {
                font-size: 1.5rem;
                padding: 15px 30px;
            }
        }
        canvas {
            display: block;
        }
        #matrixCanvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }
        #fireworks3dContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none; /* Hide initially */
        }
        .intro-text, .countdown, .dynamic-text, .card-message, .start-button {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            font-weight: bold;
            color: #00bfff; /* Updated to a brighter blue */
            text-shadow: 0 0 15px #00bfff; /* Updated text shadow */
            z-index: 20;
            opacity: 0;
            transition: opacity 1s ease-in-out;
            text-align: center;
        }
        
        .start-button {
            background: linear-gradient(45deg, #00bfff, #0080ff);
            border: 2px solid #00bfff;
            border-radius: 15px;
            padding: 20px 40px;
            font-size: 2rem;
            color: white;
            cursor: pointer;
            box-shadow: 0 0 20px rgba(0, 191, 255, 0.5);
            transition: all 0.3s ease;
            opacity: 1;
        }
        
        .start-button:hover {
            background: linear-gradient(45deg, #0080ff, #00bfff);
            box-shadow: 0 0 30px rgba(0, 191, 255, 0.8);
            transform: translate(-50%, -50%) scale(1.05);
        }
        
        .start-button:active {
            transform: translate(-50%, -50%) scale(0.95);
        }
        .countdown {
            font-size: 8rem;
            color: #fff;
            text-shadow: 0 0 20px #00bfff;
            z-index: 10;
        }
        .dynamic-text {
            font-size: 5rem;
            color: #00bfff; /* Updated to a brighter blue */
            text-shadow: 0 0 10px #00bfff; /* Updated text shadow */
            z-index: 15;
            white-space: nowrap;
        }
        .card-message {
            /* C·∫≠p nh·∫≠t v·ªã tr√≠ ƒë·ªÉ n√≥ xu·∫•t hi·ªán ph√≠a d∆∞·ªõi tr√°i tim */
            top: 75%;
            font-size: 2.5rem; /* Adjusted font size to be smaller */
            color: #fff;
            text-shadow: 0 0 10px #fff;
            white-space: nowrap;
            opacity: 0;
            transition: opacity 1s ease-in-out;
            z-index: 25; /* Higher z-index to be on top */
        }
        
        /* Container for heart particles */
        #heartContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 16;
        }

        /* Heart effect */
        .heart-particle {
            position: absolute;
            width: 20px;
            height: 20px;
            background-color: #00bfff; /* Updated heart color to blue */
            transform: rotate(-45deg);
            opacity: 0;
            animation: heart-fall linear infinite;
        }

        .heart-particle::before,
        .heart-particle::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            background-color: #00bfff; /* Updated heart color to blue */
            border-radius: 50%;
        }

        .heart-particle::before {
            top: -10px;
            left: 0;
        }

        .heart-particle::after {
            left: 10px;
            top: 0;
        }

        @keyframes heart-fall {
            0% {
                transform: translateY(0) rotate(-45deg) scale(0);
                opacity: 0;
            }
            10% {
                transform: translateY(0) rotate(-45deg) scale(1);
                opacity: 1;
            }
            100% {
                transform: translateY(100vh) rotate(-45deg) scale(0);
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <!-- Orientation warning overlay -->
    <div id="orientationWarning">
        <div class="rotate-icon">üì±</div>
        <div class="warning-text">Vui l√≤ng xoay ngang ƒëi·ªán tho·∫°i</div>
        <div class="sub-text">ƒë·ªÉ c√≥ tr·∫£i nghi·ªám t·ªët nh·∫•t</div>
    </div>

    <!-- Canvas for the 2D Matrix effect -->
    <canvas id="matrixCanvas"></canvas>
    
    <!-- Container for heart particles -->
    <div id="heartContainer"></div>

    <!-- Container for 3D Three.js scene -->
    <div id="fireworks3dContainer"></div>

    <!-- Start button -->
    <button id="startButton" class="start-button">üéâ B·∫Øt ƒë·∫ßu ngay! üéâ</button>

    <!-- Countdown effect -->
    <div id="countdown" class="countdown">3</div>

    <!-- Dynamic text overlay for the initial sequence -->
    <div id="dynamicText" class="dynamic-text"></div>

    <!-- New element for the card message -->
    <div id="cardMessage" class="card-message"></div>

    <!-- Audio element for background music. -->
    <!-- Loop attribute ensures the music plays continuously. -->
    <audio id="birthdayMusic" loop>
        <source src="https://storage.googleapis.com/gemini-prod-us-west1-1p-20240506-121513/6928935147941.mp3" type="audio/mpeg">
        Tr√¨nh duy·ªát c·ªßa b·∫°n kh√¥ng h·ªó tr·ª£ ph·∫ßn t·ª≠ audio.
    </audio>
    
    <script>
        const matrixCanvas = document.getElementById('matrixCanvas');
        const matrixCtx = matrixCanvas.getContext('2d');
        const startButtonElement = document.getElementById('startButton');
        const countdownElement = document.getElementById('countdown');
        const dynamicTextElement = document.getElementById('dynamicText');
        const cardMessageElement = document.getElementById('cardMessage');
        const heartContainer = document.getElementById('heartContainer');
        const fireworks3dContainer = document.getElementById('fireworks3dContainer');
        const birthdayMusic = document.getElementById('birthdayMusic'); // Get the audio element

        // Get screen dimensions
        const width = window.innerWidth;
        const height = window.innerHeight;
        matrixCanvas.width = width;
        matrixCanvas.height = height;

        // Matrix effect variables
        const oceanCharacters = "happy birthday ";
        const characters = oceanCharacters.split('');
        const fontSize = 16;
        let columns = Math.floor(width / fontSize);
        let rows = Math.floor(height / fontSize);
        const drops = [];
        for (let i = 0; i < columns; i++) {
            drops[i] = 1;
        }
        let matrixInterval;
        let isMatrixRunning = false;
        let heartInterval;
        
        // Heart formation variables
        let isFormingHeart = false;
        let heartFormationProgress = 0;
        let heartPositions = [];
        let leftHeartPositions = [];
        let rightHeartPositions = [];
        let matrixGrid = [];

        // Three.js variables
        let scene, camera, renderer, particles, particleGeometry, sparkleParticles;
        const particleCount = 30000; // Increased particle count for better density
        let targetPositions = [];
        let isHeartForming = false;
        let animationFrameId;
        let heartAnimationPhase = 'explosion'; // 'explosion', 'blooming', 'sparkling', 'breathing'
        let heartAnimationTime = 0;
        let heartBloomScale = 0.1; // Start very small
        let sparklePositions = [];

        // Generate heart shape positions split into left and right
        function generateHeartPositions() {
            heartPositions = [];
            leftHeartPositions = [];
            rightHeartPositions = [];
            
            const centerX = Math.floor(columns / 2);
            const centerY = Math.floor(rows / 2);
            const scale = Math.min(columns, rows) * 0.15; // Scale based on screen size
            
            // Heart equation: (x^2 + y^2 - 1)^3 - x^2*y^3 = 0
            // Simplified for pixel grid
            for (let t = 0; t < Math.PI * 2; t += 0.08) {
                const x = 16 * Math.pow(Math.sin(t), 3);
                const y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
                
                const pixelX = Math.floor(centerX + (x * scale) / 16);
                const pixelY = Math.floor(centerY - (y * scale) / 16); // Invert Y for screen coordinates
                
                if (pixelX >= 0 && pixelX < columns && pixelY >= 0 && pixelY < rows) {
                    const heartPos = { 
                        x: pixelX, 
                        y: pixelY,
                        finalX: pixelX,
                        finalY: pixelY
                    };
                    
                    heartPositions.push(heartPos);
                    
                    // Split into left and right halves
                    if (pixelX <= centerX) {
                        // Left side starts from left edge
                        leftHeartPositions.push({
                            ...heartPos,
                            x: Math.floor(Math.random() * centerX * 0.3), // Start from left side
                        });
                    } else {
                        // Right side starts from right edge  
                        rightHeartPositions.push({
                            ...heartPos,
                            x: Math.floor(columns - Math.random() * centerX * 0.3), // Start from right side
                        });
                    }
                }
            }
            
            // Fill heart interior and split
            const filledPositions = [...heartPositions];
            for (let y = Math.floor(centerY - scale/8); y < Math.floor(centerY + scale/8); y++) {
                for (let x = Math.floor(centerX - scale/8); x < Math.floor(centerX + scale/8); x++) {
                    const dx = (x - centerX) * 16 / scale;
                    const dy = -(y - centerY) * 16 / scale;
                    
                    // Heart equation check
                    const heartValue = Math.pow(dx * dx + dy * dy - 256, 3) - dx * dx * dy * dy * dy;
                    if (heartValue <= 0 && Math.random() < 0.15) { // Reduced fill density
                        const heartPos = { 
                            x: x, 
                            y: y,
                            finalX: x,
                            finalY: y
                        };
                        
                        filledPositions.push(heartPos);
                        
                        if (x <= centerX) {
                            leftHeartPositions.push({
                                ...heartPos,
                                x: Math.floor(Math.random() * centerX * 0.3),
                            });
                        } else {
                            rightHeartPositions.push({
                                ...heartPos,
                                x: Math.floor(columns - Math.random() * centerX * 0.3),
                            });
                        }
                    }
                }
            }
            heartPositions = filledPositions;
        }

        // Matrix animation loop with heart formation
        function drawMatrix() {
            matrixCtx.fillStyle = 'rgba(0, 0, 0, 0.05)';
            matrixCtx.fillRect(0, 0, width, height);

            if (!isFormingHeart) {
                // Normal matrix rain
                for (let i = 0; i < drops.length; i++) {
                    matrixCtx.fillStyle = '#00bfff';
                    matrixCtx.font = fontSize + 'px sans-serif';
                    matrixCtx.shadowColor = '#00bfff';
                    matrixCtx.shadowBlur = 8;
                    matrixCtx.shadowOffsetX = 0;
                    matrixCtx.shadowOffsetY = 0;

                    const text = characters[Math.floor(Math.random() * characters.length)];
                    matrixCtx.fillText(text, i * fontSize, drops[i] * fontSize);

                    if (drops[i] * fontSize > height && Math.random() > 0.975) {
                        drops[i] = 0;
                    }
                    drops[i]++;
                }
            } else {
                // Heart formation phase - characters move from sides to center
                heartFormationProgress += 0.015; // Slower formation for smoother animation
                
                // Continue some matrix rain in background
                for (let i = 0; i < drops.length; i++) {
                    if (Math.random() < 0.2) { // Further reduced density
                        matrixCtx.fillStyle = 'rgba(0, 191, 255, 0.2)';
                        matrixCtx.font = fontSize + 'px sans-serif';
                        matrixCtx.shadowColor = '#00bfff';
                        matrixCtx.shadowBlur = 2;
                        
                        const text = characters[Math.floor(Math.random() * characters.length)];
                        matrixCtx.fillText(text, i * fontSize, drops[i] * fontSize);
                        
                        if (drops[i] * fontSize > height && Math.random() > 0.975) {
                            drops[i] = 0;
                        }
                        drops[i]++;
                    }
                }
                
                // Draw moving heart characters
                const progress = Math.min(heartFormationProgress, 1);
                
                // Draw left side moving to center
                for (let i = 0; i < leftHeartPositions.length; i++) {
                    const pos = leftHeartPositions[i];
                    const currentX = pos.x + (pos.finalX - pos.x) * progress;
                    const currentY = pos.y + (pos.finalY - pos.y) * progress * 0.3; // Slight Y movement
                    
                    matrixCtx.fillStyle = '#00bfff';
                    matrixCtx.font = fontSize + 'px sans-serif';
                    matrixCtx.shadowColor = '#00bfff';
                    matrixCtx.shadowBlur = 8;
                    
                    const char = '‚ù§';
                    matrixCtx.fillText(char, currentX * fontSize, currentY * fontSize);
                }
                
                // Draw right side moving to center
                for (let i = 0; i < rightHeartPositions.length; i++) {
                    const pos = rightHeartPositions[i];
                    const currentX = pos.x + (pos.finalX - pos.x) * progress;
                    const currentY = pos.y + (pos.finalY - pos.y) * progress * 0.3; // Slight Y movement
                    
                    matrixCtx.fillStyle = '#00bfff';
                    matrixCtx.font = fontSize + 'px sans-serif';
                    matrixCtx.shadowColor = '#00bfff';
                    matrixCtx.shadowBlur = 8;
                    
                    const char = '‚ù§';
                    matrixCtx.fillText(char, currentX * fontSize, currentY * fontSize);
                }
            }
        }

        // Handle window resizing and orientation changes
        function handleResize() {
            const newWidth = window.innerWidth;
            const newHeight = window.innerHeight;
            
            matrixCanvas.width = newWidth;
            matrixCanvas.height = newHeight;
            
            if (camera) {
                camera.aspect = newWidth / newHeight;
                camera.updateProjectionMatrix();
            }
            if (renderer) {
                renderer.setSize(newWidth, newHeight);
            }
            
            // Recalculate matrix columns and rows for new dimensions
            columns = Math.floor(newWidth / fontSize);
            rows = Math.floor(newHeight / fontSize);
            drops.length = columns;
            for (let i = 0; i < columns; i++) {
                if (drops[i] === undefined) {
                    drops[i] = 1;
                }
            }
            
            // Regenerate heart positions for new screen size
            if (isFormingHeart) {
                generateHeartPositions();
            }
        }

        window.addEventListener('resize', handleResize);
        window.addEventListener('orientationchange', () => {
            // Delay to allow orientation change to complete
            setTimeout(handleResize, 100);
        });

        // Start button click handler
        startButtonElement.addEventListener('click', function() {
            // Hide start button with animation
            startButtonElement.style.opacity = 0;
            setTimeout(() => {
                startButtonElement.style.display = 'none';
                startCountdown();
            }, 500);
        });

        // Countdown function
        let countdown = 3;
        function startCountdown() {
            countdownElement.style.opacity = 1;
            const countdownInterval = setInterval(() => {
                countdown--;
                if (countdown > 0) {
                    countdownElement.textContent = countdown;
                } else {
                    clearInterval(countdownInterval);
                    countdownElement.style.opacity = 0;
                    setTimeout(() => {
                        countdownElement.style.display = 'none';
                        showDynamicTextSequence();
                    }, 1000);
                }
            }, 1000);
        }

        // Default hardcoded dynamic messages
        const defaultDynamicMessages = [
            "HAPPY",
            "BIRTHDAY",
            "TO",
            "ANH THY",
            "28.08.2004"
        ];
        let dynamicIndex = 0;

        // Display dynamic messages
        function showDynamicTextSequence() {
            if (dynamicIndex < defaultDynamicMessages.length) {
                dynamicTextElement.textContent = defaultDynamicMessages[dynamicIndex];
                dynamicTextElement.style.opacity = 1;
                
                if (dynamicIndex === 0 && !isMatrixRunning) {
                    matrixInterval = setInterval(drawMatrix, 50);
                    isMatrixRunning = true;
                }

                // Don't start heart formation during text sequence
                // Wait until after "28.08.2004" is shown
                
                let displayDuration = 2500;
                if (defaultDynamicMessages[dynamicIndex].length > 20) {
                    displayDuration = 4000; // Longer duration for longer messages
                }

                setTimeout(() => {
                    dynamicTextElement.style.opacity = 0;
                    setTimeout(showDynamicTextSequence, 1000);
                }, displayDuration);
                dynamicIndex++;
            } else {
                // All messages have been shown, now start heart formation
                if (!isFormingHeart) {
                    isFormingHeart = true;
                    generateHeartPositions();
                    heartFormationProgress = 0; // Reset progress
                }
                
                // Show card message after heart formation completes
                setTimeout(() => {
                    // Check if heart formation is complete before showing message
                    const checkHeartComplete = setInterval(() => {
                        if (heartFormationProgress >= 1) {
                            clearInterval(checkHeartComplete);
                            setTimeout(() => {
                                showCardMessage();
                            }, 1000); // Wait 1 second after heart is fully formed
                        }
                    }, 100);
                }, 500);
            }
        }
        
        // Remove the old heart particle function - no longer needed
        // Matrix heart formation replaces this functionality

        // Three.js initialization and animation
        function start3DEffect() {
            fireworks3dContainer.style.display = 'block';

            // Start playing the music
            birthdayMusic.play().catch(error => {
                // Catches and handles potential autoplay errors in some browsers
                console.log("Autoplay was prevented. User interaction required to play music.");
            });

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            camera.position.z = 100; 
            camera.position.y = -5; // Adjusted camera position to vertically center the heart

            renderer = new THREE.WebGLRenderer({ alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(width, height);
            fireworks3dContainer.appendChild(renderer.domElement);
            
            // Create particles
            particleGeometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const velocities = [];
            
            // Color for particles (a range of blues)
            const color = new THREE.Color();

            for (let i = 0; i < particleCount; i++) {
                positions.push(0, 0, 0);
                const speed = Math.random() * 1.5 + 0.5;
                const angle1 = Math.random() * 2 * Math.PI;
                const angle2 = Math.random() * 2 * Math.PI;
                velocities.push(
                    Math.cos(angle1) * speed,
                    Math.sin(angle1) * speed,
                    Math.cos(angle2) * Math.sin(angle1) * speed
                );

                // Th√™m m·ªôt d·∫£i m√†u xanh bi·ªÉn c·∫£ r·ª±c r·ª°
                color.setHSL(0.55 + Math.random() * 0.15, 1, 0.5 + Math.random() * 0.5);
                colors.push(color.r, color.g, color.b);
            }

            particleGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            particleGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            
            const particleMaterial = new THREE.PointsMaterial({
                size: 1.2, // Updated: Reduced particle size for a finer effect
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                transparent: true,
                opacity: 0.8
            });

            particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);

            // Create sparkle particles
            createSparkleSystem();

            // Pre-calculate target positions for the heart shape
            targetPositions = createHeartShapePoints(particleCount, 50); // smaller scale

            // Store the velocities array in userData so animateExplosion can access it
            particleGeometry.userData.velocities = velocities;

            // Start the explosion animation
            animateExplosion();

            // After 3 seconds, start the heart blooming sequence
            setTimeout(() => {
                isHeartForming = true;
                heartAnimationPhase = 'blooming';
                dynamicTextElement.style.opacity = 0;
            }, 3000);

            // After the heart animation sequence, show the card message
            setTimeout(() => {
                showCardMessage();
            }, 8500); // Wait for bloom + sparkle + breathing phases to settle

        }

        /**
         * Generates points to fill the volume of a heart shape.
         * @param {number} count The number of particles to generate.
         * @param {number} scale The scale of the heart shape.
         * @returns {Array<{x: number, y: number, z: number}>} An array of point coordinates.
         */
        function createHeartShapePoints(count, scale) {
            const points = [];
            const zThickness = 40; 
            for (let i = 0; i < count; i++) {
                // Generate a random angle on the 2D heart curve
                const t = Math.random() * 2 * Math.PI;
                
                // Generate a random factor to scale the point inward, filling the volume.
                // Using a power function (Math.pow) biases the numbers towards 1,
                // making the outer edge denser.
                const s = Math.pow(Math.random(), 0.3); 
                
                // Calculate heart shape coordinates
                const x = 16 * Math.pow(Math.sin(t), 3);
                const y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
                
                // Apply the scaling factor to fill the 2D area
                const newX = x * s;
                const newY = y * s;
                
                // Add a random Z-coordinate for 3D thickness
                const newZ = (Math.random() - 0.5) * zThickness;
                
                points.push({
                    x: newX * scale * 0.05,
                    y: newY * scale * 0.05,
                    z: newZ * scale * 0.05
                });
            }
            return points;
        }

        // Create sparkle particle system
        function createSparkleSystem() {
            const sparkleCount = 200;
            const sparkleGeometry = new THREE.BufferGeometry();
            const sparklePositions = [];
            const sparkleColors = [];
            const sparkleOpacities = [];
            
            for (let i = 0; i < sparkleCount; i++) {
                // Random positions around heart area
                const radius = 60 + Math.random() * 40;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                
                sparklePositions.push(
                    radius * Math.sin(phi) * Math.cos(theta),
                    radius * Math.cos(phi),
                    radius * Math.sin(phi) * Math.sin(theta)
                );
                
                // Sparkle colors (white to light blue)
                const color = new THREE.Color();
                color.setHSL(0.55 + Math.random() * 0.1, 0.3 + Math.random() * 0.7, 0.8 + Math.random() * 0.2);
                sparkleColors.push(color.r, color.g, color.b);
                sparkleOpacities.push(0); // Start invisible
            }
            
            sparkleGeometry.setAttribute('position', new THREE.Float32BufferAttribute(sparklePositions, 3));
            sparkleGeometry.setAttribute('color', new THREE.Float32BufferAttribute(sparkleColors, 3));
            
            const sparkleMaterial = new THREE.PointsMaterial({
                size: 2,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                transparent: true,
                opacity: 0
            });
            
            sparkleParticles = new THREE.Points(sparkleGeometry, sparkleMaterial);
            scene.add(sparkleParticles);
        }

        // Animation loop for the explosion phase
        function animateExplosion() {
            animationFrameId = requestAnimationFrame(animateExplosion);

            const positions = particleGeometry.attributes.position.array;
            const velocities = particleGeometry.userData.velocities;
            
            heartAnimationTime += 0.016; // ~60fps
            
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                if (!isHeartForming) {
                    // Explosion phase: apply velocity and gravity
                    positions[i3] += velocities[i3] * 0.5;
                    positions[i3 + 1] += velocities[i3 + 1] * 0.5;
                    positions[i3 + 2] += velocities[i3 + 2] * 0.5;
                    velocities[i3 + 1] -= 0.005; // Gravity
                } else {
                    // Heart-forming phase: move towards target position
                    const targetX = targetPositions[i].x;
                    const targetY = targetPositions[i].y;
                    const targetZ = targetPositions[i].z;
                    
                    const dx = targetX - positions[i3];
                    const dy = targetY - positions[i3 + 1];
                    const dz = targetZ - positions[i3 + 2];
                    
                    positions[i3] += dx * 0.05;
                    positions[i3 + 1] += dy * 0.05;
                    positions[i3 + 2] += dz * 0.05;
                }
            }
            particleGeometry.attributes.position.needsUpdate = true;
            
            // Handle different animation phases
            handleHeartAnimation();

            renderer.render(scene, camera);
        }

        // Handle heart animation phases
        function handleHeartAnimation() {
            if (!isHeartForming) return;
            
            switch(heartAnimationPhase) {
                case 'blooming':
                    // Phase 1: Heart blooms from tiny to full size (2 seconds)
                    if (heartAnimationTime < 2) {
                        // Smooth easing function for blooming
                        const progress = heartAnimationTime / 2;
                        const easeOut = 1 - Math.pow(1 - progress, 3); // Cubic ease-out
                        heartBloomScale = 0.1 + (0.9 * easeOut);
                        particles.scale.set(heartBloomScale, heartBloomScale, heartBloomScale);
                    } else {
                        heartAnimationPhase = 'sparkling';
                        heartAnimationTime = 0; // Reset timer for next phase
                    }
                    break;
                    
                case 'sparkling':
                    // Phase 2: Sparkles appear around heart (1.5 seconds)
                    if (heartAnimationTime < 1.5) {
                        const sparkleProgress = heartAnimationTime / 1.5;
                        sparkleParticles.material.opacity = Math.sin(sparkleProgress * Math.PI) * 0.8;
                        
                        // Make sparkles twinkle
                        const sparklePositions = sparkleParticles.geometry.attributes.position.array;
                        for (let i = 0; i < sparklePositions.length; i += 3) {
                            const twinkle = Math.sin(heartAnimationTime * 8 + i) * 0.5 + 0.5;
                            sparklePositions[i + 1] += Math.sin(heartAnimationTime * 2 + i) * 0.2;
                        }
                        sparkleParticles.geometry.attributes.position.needsUpdate = true;
                    } else {
                        heartAnimationPhase = 'breathing';
                        heartAnimationTime = 0;
                    }
                    break;
                    
                case 'breathing':
                    // Phase 3: Gentle breathing effect (ongoing)
                    const breathScale = 1 + 0.02 * Math.sin(heartAnimationTime * 1.5); // Slower, gentler
                    particles.scale.set(breathScale, breathScale, breathScale);
                    
                    // Gentle sparkle fade and twinkle
                    const sparkleOpacity = 0.3 + 0.2 * Math.sin(heartAnimationTime * 0.8);
                    sparkleParticles.material.opacity = sparkleOpacity;
                    break;
            }
        }

        // Show card message function (simplified)
        function showCardMessage() {
            const message = "Ch·ªã m·ªü t·∫•m thi·ªáp ra ƒëi nha";
            cardMessageElement.textContent = message;
            cardMessageElement.style.opacity = 1;

            // Add a pulsating effect to the text-shadow
            setInterval(() => {
                cardMessageElement.style.textShadow = `0 0 15px #fff, 0 0 25px #00bfff, 0 0 35px #00bfff`;
                setTimeout(() => {
                    cardMessageElement.style.textShadow = `0 0 10px #fff`;
                }, 500);
            }, 1000);
        }

        // Show start button when the page loads
        window.onload = () => {
            startButtonElement.style.opacity = 1;
        };
    </script>
</body>
</html>
